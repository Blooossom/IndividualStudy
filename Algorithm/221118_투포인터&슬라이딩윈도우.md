# Two Pointer & Sliding Window

<aside>
<h2>💡 투 포인터 개요</h2>

</aside>

- 투 포인터는 간단히 말해서 연속되는 value들을 이용하여 특정 목표에 맞는 값을 찾아주는 알고리즘이라고 할 수 있음
- 여기서 주의해야할 것은 어디까지나 연속된 값들을 이용하여 풀어나가는 문제에 한정적으로 사용해야 한다는 것
- 만일 주어진 값들의 연속성이 선행조건으로 주어지지 않는 경우에는 투 포인터를 사용할 수 없음
- 그런 면에서 문제에서 주어진 값들을 그대로 활용해야하는 경우나 정렬을 통하여 연속성을 추가해줄 수 있는 경우에 사용할 수 있는 알고리즘임
 
<br>
<aside>
<h2>💡 방법?</h2>

</aside>

- 투 포인터를 이용하여 문제를 풀이하는 방법은 간단함
- 우선 정수로 이루어진 배열이 있다고 가정하고,
- 그리고 그 정수들 중 연속된 몇 개의 정수들의 합이 특정 값이 된다고 하였을 때, 그 값을 만들 수 있는 조합은 몇 가지가 될 것이냐라는 문제가 있다고 하자.
- 만일 투포인터를 사용하지 않는다면 백트래킹 등을 이용하여 나올 수 있는 모든 케이스에 대해 탐색하는 것이 최선임
- 다만 문제를 출제하는 사람은 투 포인터를 생각하고 문제를 출제하였을 것이기 때문에, 필연적으로 시간 초과가 발생함
- 위와 같은 문제에 사용할 수 있는 것이 투 포인터임.
- 투 포인터는 우선 배열을 가르키는 두 개의 포인터를 만듬
- 두 개의 포인터는 각각 배열에서 특정 위치를 지정해주는 시작점과 끝점이라고 할 수 있음
- 그리고 그 포인터를 이동시켜가면서 우릭 원하는 값을 찾아주는 것
- 위 문제에서는 배열 내 연속된 숫자들의 합을 이용하는 것이므로 더해가면서 값을 찾아주어야 할 것임
- 두 개의 포인터를 정수들을 더해주는 과정에서 움직이게 됨
- 이때 우리가 원하는 값이 나왔다면 답을 계산해줄 count 변수에 하나의 값을 더해주고 그렇지 않은 경우라면 조건에 따라 start pointer와 end pointer를 이동시켜줌
- end pointer는 현재 포함된 값들의 합이 원하는 값보다 작은 경우에 이동시켜줌
- 현재까지 등장한 숫자들로는 원하는 값을 만들 수 없었기 때문ㅇ
- start pointer는 원하는 값을 찾았거나, 그보다 값이 큰 경우에 이동시켜주는데, 이는 현재까지 등장했던 숫자들을 이용하여 원하는 값을 찾은 이상 지금까지 포함도니 숫자들에 새로운 숫자들을 더해서는 웒나느 값을 찾을 수 없다는 가정이 포함되어있기 때문

<br>

```java
package AlgorithmSrc;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class TwoPointer {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] arr = new int[n];
        for (int i = 0; i <arr.length ; i++) {
            arr[i]= Integer.parseInt(st.nextToken());
        }
        int x = Integer.parseInt(br.readLine());
        System.out.println(twoPointer(arr,x));
    }
    public static int twoPointer(int[] arr, int m){
        int count = 0;
        int sp = 0;
        int ep = 0;
        int sum = 0;
        while (true) {
            if(sum>=m){
                sum -= arr[sp++];
            } else if (ep>=arr.length) {
                break;
            }else{
                sum += arr[ep++];
            }
            if(sum==m){
                count++;
            }
        }
        return count;
    }
}
```
<br>
<aside>
<h2>💡 슬라이딩 윈도우</h2>

</aside>

- 때에 따라서 투 포인터와 슬라이딩 윈도우를 구분없이 이야기하거나 개념이 혼동되는 경우가 꽤 있을 정도로 둘은 유사한 접근 방식을 가지고 있는 알고리즘임
- 투 포인터는 위에서 언급한 것처럼 연속적인 데이터가 주어졌을 때
- 두 개의 포인터를 이용하여 범위를 정해주고, 그 범위에 포함된 데이터의 합 등 연산을 한 뒤 그것이 원하는 값인지 검증을 하고 조건에 맞지 않는다면 조건에 맞출 수 있도록 endPointer나 startPointer를 적절하게 이동시켜주면서 모든 데이터를 확인하는 방식의 알고리즘이었음
- 슬라이딩 윈도우는 투 포인터와 유사하게 접근하되, 투 포인터처럼 범위의 크기가 줄었다 늘었다 하는 것이 아니라, 일정한 크기를 유지하면서 이동한다는 점에서 차이가 있음
- 그렇기 때문에 투 포인터처럼 데이터의 크기와 데이터의 값이 주어지는 동시에 특정 범위가 주어지고 그 범위 내에서 연산처리가 이루어지도록 요구하고 있다면 슬라이딩 윈도우 문제로 볼 수 있음
<br>
<aside>
<h2>💡 예시</h2>

</aside>

- 숫자 N개의 범위 L이 주어지고, 인덱스 i가 -에서부터 N까지 증가할 때 i-L+1에서 i까지의 인덱스 내에 있는 수들 중에서 가장 작은 수를 찾아 출력해주는 문제가 있다고 가정
- 아래는 N=12, L=3인 경우의 예시
- 

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 5 | 2 | 3 | 6 | 2 | 3 | 7 | 3 | 5 | 2 | 6 |
- 인덱스가 0과 1인 경우 시작점이 음수가 되어 문제의 범위를 벗어나게 되는데 이 경우는 벗어나는 부분을 제외한 범위 내에서 가장 작은 수를 찾아주는 문제로 이해하고 풀면 됨
- 일단 이 문제를 풀기에 앞서 리스 하나를 준비
- 리스트에는 문제의 답이 될 수 있는 인덱스를 저장해둘 것
- 리스트는 인덱스를 키워가면서 답이 될 가능성이 없는 수들의 인덱스를 리스트에서 제거해 나감
- 또한 인덱스가 커지면서 범위에서 벗어나 더 이상 답이 될 수 없는 경우에도 리스트에서 제거할 것
- 위와 같이 수들이 주어진 경우 i가 0인 경우, 즉 범위에 다른 수들이 포함되어있지 않고 0에 해당하는 숫자 1만 범위에 들어온 경우라면 범위 내 최소값은 1이라는 것을 알 수가 있음
- [0] : 그 다음 인덱스 1번쨰의 값 5부터는 이 값이 기존의 최소값을 대체할 수 있는 지를 확인하는 작업이 필요
- 만일 5가 기존 리스트에 들어있는 값들보다 작은 값이라면 앞으로 최소값을 출력할 때는 기존값들을 대체하여 5가 출력되어야 할것
- 하지만 5는 1보다 크기 때문에 여전이 1은 리스트에 존재
- [0,1] : 그 다음 인덱스 2번째의 값 2를 확인하게 되면 2가 5를 대체할 수 있다는 것을 알게 됨
- 범위 내에 5보다 작은 2가 생겼고 이 값이 범위에 들어온 이상 5는 최소값으로 사용안됨
- 그렇기 때문에 2보다 큰값은 리스트에 남아있을 이유가 없음
- 리스트에서 순차적으로 5보다 큰 값을 제거
- 리스트는 아래 경우로 변함
- [0,2]: 그 다음 인덱스 3인 경우 최초로 범위에 포함되지 않아 리스트에서 제거되어야 하는 값이 생김
- 인덱스 0인 값은 범위 3에 포함되지 않기 때문에 리스트에 있을 수 없게 됨
- 리스트에서 범위에서 벗어난 값들을 제거
- 3은 2보다 크기 때문에 2는 리스트에 포함될 수 있음 그리고 지속적으로 범위 내에서 가장 작은 숫자에 해당하게 됨 > [2,3]
